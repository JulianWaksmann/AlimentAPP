"""Gestion de materia prima: verifica stock, asigna lotes y dispara compras si falta insumo."""
import json
import logging
import math
import os
import ssl
from decimal import Decimal
from typing import Any, Dict, Iterable, List, Optional
from datetime import datetime, timezone

import urllib.request
import urllib.error

import boto3
import pg8000

logger = logging.getLogger()
logger.setLevel(logging.INFO)

ENV = os.getenv("DB_SCHEMA", "dev")
ssm_client = boto3.client("ssm")
lambda_client = boto3.client("lambda")

DB_CONFIG: Optional[Dict[str, Any]] = None

LAMBDA_ASIGNAR_MP = "asignacion-lote-materia-prima-orden-produccion"
LAMBDA_GENERAR_COMPRA_MP = "post-generar-compra-lote-materia-prima"


def get_db_parameters() -> Dict[str, Any]:
    global DB_CONFIG
    if DB_CONFIG:
        return DB_CONFIG

    param_names = [
        "/alimentapp/db/host",
        "/alimentapp/db/password",
        "/alimentapp/db/port",
        "/alimentapp/db/username",
    ]
    resp = ssm_client.get_parameters(Names=param_names, WithDecryption=True)
    if len(resp["Parameters"]) != len(param_names):
        missing = set(param_names) - {p["Name"] for p in resp["Parameters"]}
        raise RuntimeError(f"Parámetros faltantes en SSM: {', '.join(sorted(missing))}")

    data = {p["Name"].split("/")[-1]: p["Value"] for p in resp["Parameters"]}
    DB_CONFIG = {
        "host": data["host"],
        "port": int(data.get("port", "5432")),
        "user": data["username"],
        "password": data["password"],
        "database": os.getenv("DB_NAME", "postgres"),
    }
    return DB_CONFIG


def get_connection():
    cfg = get_db_parameters()
    return pg8000.connect(
        host=cfg["host"],
        port=cfg["port"],
        database=cfg["database"],
        user=cfg["user"],
        password=cfg["password"],
        ssl_context=ssl.create_default_context(),
        timeout=10,
    )


def run_query(cur, sql: str, params: Iterable[Any] = None) -> List[Dict[str, Any]]:
    cur.execute(sql, tuple(params or ()))
    rows = cur.fetchall()
    if not rows:
        return []
    columns = [desc[0] for desc in cur.description]
    return [dict(zip(columns, row)) for row in rows]


def fetch_one(cur, sql: str, params: Iterable[Any] = None) -> Optional[Dict[str, Any]]:
    cur.execute(sql, tuple(params or ()))
    row = cur.fetchone()
    if not row:
        return None
    columns = [desc[0] for desc in cur.description]
    return dict(zip(columns, row))


def get_cheapest_provider(cur, materia_id: int) -> Optional[Dict[str, Any]]:
    sql = f"""
        SELECT id_proveedor, precio
        FROM {ENV}.proveedor_por_materia_prima
        WHERE id_materia_prima = %s AND activo = TRUE
        ORDER BY precio ASC NULLS LAST, id
        LIMIT 1
    """
    rows = run_query(cur, sql, (materia_id,))
    return rows[0] if rows else None


def get_materia_prima_config(cur, materia_id: int) -> Optional[Dict[str, Any]]:
    sql = f"""
        SELECT cantidad_por_unidad_compra, unidad_medida, nombre
        FROM {ENV}.materia_prima
        WHERE id = %s
    """
    return fetch_one(cur, sql, (materia_id,))


def check_raw_material_availability(cur, id_orden_venta: int) -> Dict[str, Any]:
    """Verifica stock para las OP del pedido, manteniendo un conteo efímero."""
    # Todas las OP se procesan en orden ascendente para mantener consistencia del conteo efímero.
    ordenes_produccion = run_query(
        cur,
        f"""
        SELECT id, id_producto, cantidad
        FROM {ENV}.orden_produccion
        WHERE id_orden_venta = %s
        ORDER BY id ASC
        """,
        (id_orden_venta,),
    )
    if not ordenes_produccion:
        return {
            "ordenes_con_stock_suficiente": [],
            "ordenes_con_stock_insuficiente": [],
            "consolidado_faltantes": [],
        }

    product_ids = tuple(op["id_producto"] for op in ordenes_produccion)
    receta_rows = (
        run_query(
            cur,
            f"""
            SELECT id_producto, id_materia_prima, cantidad_unitaria
            FROM {ENV}.materia_prima_por_producto
            WHERE id_producto IN ({', '.join(['%s'] * len(product_ids))})
            """,
            product_ids,
        )
        if product_ids
        else []
    )

    recetas_por_producto: Dict[int, List[Dict[str, Any]]] = {}
    for row in receta_rows:
        recetas_por_producto.setdefault(row["id_producto"], []).append(row)

    materia_ids = tuple({r["id_materia_prima"] for r in receta_rows})
    stock_rows = (
        run_query(
            cur,
            f"""
            SELECT id_materia_prima, cantidad_disponible
            FROM {ENV}.cantidad_disponible_materia_prima
            WHERE id_materia_prima IN ({', '.join(['%s'] * len(materia_ids))})
            """,
            materia_ids,
        )
        if materia_ids
        else []
    )
    stock_disponible = {
        row["id_materia_prima"]: Decimal(str(row["cantidad_disponible"]))
        for row in stock_rows
    }

    stock_efimero = stock_disponible.copy()
    ordenes_suficientes: List[int] = []
    ordenes_insuficientes: List[int] = []
    faltantes_consolidados: Dict[int, Decimal] = {}

    for op in ordenes_produccion:
        # Para cada OP calculamos los requisitos por materia prima y verificamos si alcanza el stock efímero.
        receta = recetas_por_producto.get(op["id_producto"], [])
        requisitos: Dict[int, Decimal] = {}
        se_puede = True

        for ingrediente in receta:
            materia_id = ingrediente["id_materia_prima"]
            por_unidad = Decimal(str(ingrediente["cantidad_unitaria"]))
            requerido = Decimal(str(op["cantidad"])) * por_unidad
            requisitos[materia_id] = requerido
            if stock_efimero.get(materia_id, Decimal("0")) < requerido:
                se_puede = False

        if se_puede:
            # Como alcanza, marcamos la OP como suficiente y descontamos del stock efímero.
            ordenes_suficientes.append(op["id"])
            for materia_id, requerido in requisitos.items():
                stock_efimero[materia_id] = stock_efimero.get(materia_id, Decimal("0")) - requerido
        else:
            # No alcanza: registramos faltantes para luego generar pedidos.
            ordenes_insuficientes.append(op["id"])
            for materia_id, requerido in requisitos.items():
                faltantes_consolidados[materia_id] = faltantes_consolidados.get(materia_id, Decimal("0")) + requerido

    lista_faltantes = [
        {"id_materia_prima": materia_id, "cantidad_necesaria": str(total)}
        for materia_id, total in faltantes_consolidados.items()
    ]

    return {
        "ordenes_con_stock_suficiente": ordenes_suficientes,
        "ordenes_con_stock_insuficiente": ordenes_insuficientes,
        "consolidado_faltantes": lista_faltantes,
    }


def lambda_handler(event, context):
    logger.info("Iniciando gestión de materia prima para el evento: %s", json.dumps(event))

    id_orden_venta = event.get("id_orden_venta")
    if not id_orden_venta:
        logger.error("El evento no contiene 'id_orden_venta'.")
        return {
            "statusCode": 400,
            "body": json.dumps({"error": "Falta 'id_orden_venta' en el evento."}),
        }

    conn = None
    try:
        conn = get_connection()
        cur = conn.cursor()

        resultado_verificacion = check_raw_material_availability(cur, id_orden_venta)
        logger.info(
            "Resultado de la verificación de stock: %s",
            json.dumps(resultado_verificacion, default=str),
        )

        ids_suficientes = resultado_verificacion.get("ordenes_con_stock_suficiente", [])
        asignacion_materia: Optional[Dict[str, Any]] = None
        if ids_suficientes:
            try:
                # Invocamos la lambda de asignación automática para las OP que ya tienen stock.
                payload = json.dumps({"ordenes_produccion": ids_suficientes}).encode("utf-8")
                response = lambda_client.invoke(
                    FunctionName=LAMBDA_ASIGNAR_MP,
                    InvocationType="RequestResponse",
                    Payload=payload,
                    )
                raw_body = (
                    response.get("Payload").read().decode("utf-8")
                    if response.get("Payload")
                    else "{}"
                )
                asignacion_materia = {
                    "status_code": response.get("StatusCode"),
                    "body": json.loads(raw_body or "{}"),
                }
            except Exception as exc:  # pragma: no cover
                logger.exception("Fallo al invocar la lambda de asignacion de materia prima")
                asignacion_materia = {"error": str(exc)}

        pedidos_generados: List[Dict[str, Any]] = []
        pedidos_fallidos: List[Dict[str, Any]] = []
        fecha_actual = datetime.now(timezone.utc)

        for faltante in resultado_verificacion.get("consolidado_faltantes", []):
            materia_id = int(faltante["id_materia_prima"])
            cantidad_necesaria = Decimal(str(faltante["cantidad_necesaria"]))

            # Obtenemos configuración del insumo para convertir unidades a paquetes de compra.
            materia_info = get_materia_prima_config(cur, materia_id)
            if not materia_info:
                pedidos_fallidos.append(
                    {
                        "id_materia_prima": materia_id,
                        "motivo": "Materia prima inexistente",
                    }
                )
                continue

            cantidad_por_unidad = Decimal(str(materia_info["cantidad_por_unidad_compra"] or 0))
            if cantidad_por_unidad <= 0:
                pedidos_fallidos.append(
                    {
                        "id_materia_prima": materia_id,
                        "motivo": "cantidad_por_unidad_compra no configurada",
                    }
                )
                continue

            paquetes = math.ceil(float(cantidad_necesaria / cantidad_por_unidad))
            if paquetes <= 0:
                continue

            proveedor = get_cheapest_provider(cur, materia_id)
            if not proveedor:
                pedidos_fallidos.append(
                    {
                        "id_materia_prima": materia_id,
                        "cantidad_paquetes": paquetes,
                        "motivo": "Sin proveedor activo",
                    }
                )
                continue

            try:
                logger.info(
                    "Generando pedido: materia_prima=%s paquetes=%s proveedor=%s",
                    materia_id,
                    paquetes,
                    proveedor["id_proveedor"],
                )
                payload = json.dumps(
                    {
                        "id_materia_prima": materia_id,
                        "id_proveedor": proveedor["id_proveedor"],
                        "cantidad_total": paquetes,
                    }
                ).encode("utf-8")
                response = lambda_client.invoke(
                    FunctionName=LAMBDA_GENERAR_COMPRA_MP,
                    InvocationType="RequestResponse",
                    Payload=payload,
                )
                raw_body = (
                    response.get("Payload").read().decode("utf-8")
                    if response.get("Payload")
                    else "{}"
                )
                pedidos_generados.append(
                    {
                        "id_materia_prima": materia_id,
                        "id_proveedor": proveedor["id_proveedor"],
                        "cantidad_paquetes": paquetes,
                        "response": {
                            "status_code": response.get("StatusCode"),
                            "body": json.loads(raw_body or "{}"),
                        },
                    }
                )
            except Exception as exc:  # pragma: no cover
                logger.exception("Fallo al invocar la lambda de compra de materia prima")
                pedidos_fallidos.append(
                    {
                        "id_materia_prima": materia_id,
                        "cantidad_paquetes": paquetes,
                        "motivo": str(exc),
                    }
                )

        return {
            "statusCode": 200,
            "body": json.dumps(
                {
                    "message": "Verificación de materia prima completada.",
                    "timestamp": fecha_actual.isoformat(),
                    "verificacion_stock": resultado_verificacion,
                    "asignacion_materia": asignacion_materia,
                    "pedidos_generados": pedidos_generados,
                    "pedidos_fallidos": pedidos_fallidos,
                },
                default=str,
            ),
        }
    except Exception as exc:  # pragma: no cover
        logger.exception("Fallo inesperado durante la gestión de materia prima")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": "Error interno del servidor", "detail": str(exc)}),
        }
    finally:
        if conn:
            conn.close()
            logger.info("Conexión a la base de datos cerrada.")
