Flujo de Asignacion de Materia Prima
===================================

Documentos relacionados
-----------------------
- 03_flujo_orden_venta.txt (dispara la necesidad).
- 04_flujo_materia_prima.txt (gestiona lotes y requisiciones).
- 01_schema_postgres.txt (DDL de tablas involucradas).
- 02_data_dictionary.txt (definiciones de campos y estados).

Objetivo
--------
Reservar automaticamente la materia prima necesaria para cada orden de produccion (OP) garantizando trazabilidad por lote y manteniendo la disponibilidad del stock en lotes.

Entradas clave
--------------
- orden_produccion: cantidad de producto a fabricar y estado actual.
- materia_prima_por_producto: receta que indica cuanta materia prima consume cada unidad del producto.
- materia_prima_por_orden_produccion: asignaciones ya registradas (consumo historico o parcial).
- lote_materia_prima: lotes disponibles con sus cantidades y fechas de vencimiento.

Resumen del proceso
-------------------
1. Se activa cuando la orden de venta pasa a `confirmada` o cuando se libera un lote (`estado` pasa a `disponible`).
2. Para cada OP pendiente de materia prima:
   - Calcular necesidad total (`cantidad_op * requerimiento_por_producto`).
   - Obtener lo ya asignado en materia_prima_por_orden_produccion.
   - Determinar el faltante por materia prima (`faltante = necesario - asignado`).
3. Si el faltante > 0, buscar lotes disponibles aplicando FEFO (fecha de vencimiento mas proxima, siempre >= hoy + 14 dias).
4. Consumir lotes iterativamente hasta cubrir el faltante:
   - Registrar cada consumo en materia_prima_por_orden_produccion.
   - Actualizar `cantidad_disponible` y estado del lote (a `agotado` si llega a 0).
5. Si la suma de lotes no cubre el faltante, registrar requisicion y dejar la OP en estado pendiente.
6. Si se cubre la necesidad, cambiar la OP a `lista_para_produccion`.

Reglas de negocio
-----------------
- FEFO estricto: siempre consumir el lote con vencimiento mas cercano dentro del umbral aceptado (>= 14 dias).
- Solo se consumen lotes `disponible`; lotes `en_cuarentena`, `rechazado`, `vencido` o `agotado` no participan.
- El algoritmo debe ser idempotente: si se ejecuta dos veces con los mismos datos, no debe duplicar asignaciones.
- Requiere transaccion/locking para evitar carreras cuando hay multiples asignaciones simultaneas.
- Si un lote asignado queda sin stock, su estado pasa a `agotado`; si su fecha de vencimiento llega a hoy/queda atras, se marca `vencido`.
- Si aparece un nuevo lote o se libera uno rechazado, el proceso retoma las OP con faltante.

Diagrama ASCII
--------------

             +-----------------------+
             | OP pendiente de lote  |
             | (estado planificada)  |
             +-----------+-----------+
                         |
                         v
             +-----------------------+
             | Calcular necesidad    |
             | total por materia     |
             +-----------+-----------+
                         |
             +-----------v-----------+
             | Calcular faltante     |
             | (necesario - asignado)|
             +-----------+-----------+
                         |
            +------------v------------+
            | faltante > 0 ?          |
            +------+------------------+
                   |SI               |NO
                   |                v
                   |      +---------------------+
                   |      | OP lista_para_      |
                   |      | produccion          |
                   |      +---------------------+
                   |
                   v
      +--------------------------+
      | Buscar lote disponible   |
      | (FEFO, venc >= hoy+14)   |
      +-----------+--------------+
                  |
            +-----v---------------+
            | Existe lote?        |
            +------+--------------+
                   |SI           |NO
                   |            v
                   |    +-----------------------+
                   |    | Generar requisicion   |
                   |    | y notificar           |
                   |    +-----------+-----------+
                   |                |
                   |                v
                   |    (esperar nuevos lotes)
                   |
                   v
      +------------------------------+
      | Consumir lote                |
      | - insertar en m_p_por_OP     |
      | - restar cantidad_disponible |
      | - actualizar estado de lote  |
      +-----------+------------------+
                  |
                  v (si faltante>0 continuar)

Implementacion sugerida
-----------------------
- **Opcion Lambda (recomendada):**
  - Lambda en Python ejecutada cuando se confirma una orden de venta y cuando un lote cambia a `disponible`.
  - Usa transacciones con nivel de aislamiento apropiado (o locking por `SELECT FOR UPDATE`) para actualizar lotes y materia_prima_por_orden_produccion.
  - Ventajas: logica versionada junto al codigo, facil de extender, centraliza auditoria, no requiere crear funciones complejas en la DB.

- **Opcion stored procedure/trigger (alternativa):**
  - Stored procedure en PostgreSQL que se invoca desde la Lambda para encapsular consumo + actualizacion en la DB.
  - Trigger directo no recomendado para toda la logica (sobre todo FEFO + requisiciones) porque es mas dificil de mantener y de auditar.

Recomendacion final
-------------------
Usar Lambdas como orquestadores:
1. Lambda `handle_order_confirmation` invoca la asignacion al confirmar OV.
2. Lambda `on_lot_released` se ejecuta cuando calidad marca un lote como disponible.
3. Cada Lambda llama a un helper comun que ejecuta el algoritmo con transaccion y actualiza la DB via pg8000.
4. Si se necesita mayor atomicidad, encapsular el bloque critico en un stored procedure pero mantener la orquestacion y las decisiones de negocio en Lambda.

Notas adicionales
-----------------
- Registrar logs y auditorias (orden, materia prima, lote, cantidades, usuario/servicio).
- Exponer estatus de asignacion en API para que Operario y Supervisor vean faltantes.
- Agregar alertas cuando una OP permanezca con faltante por encima de cierto SLA.
